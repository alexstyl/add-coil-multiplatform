{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Composables Core","text":"<p>Unstyled, fully accessible Compose Multiplatform UI components that you can customize to your heart's desire.</p> <p>Available for Compose Desktop, Compose Web (Js/WASM), Jetpack Compose (Android), iOS, and any other platform Compose can run on.</p> Dialog Dropdown Menu"},{"location":"dialog/","title":"Dialog","text":"<p>An unstyled Dialog component for Composable Multiplatform that can be used to implement Dialogs with the styling of your choice.</p> <p>Fully accessible, supports animations, offers consistent behavior across platforms and an optional background scrim.</p>"},{"location":"dialog/#installation","title":"Installation","text":"build.gradle.kts<pre><code>repositories {\n    mavenCentral()\n}\n\ndependencies {\n    implementation(\"com.composables:core:1.7.0\")\n}\n</code></pre>"},{"location":"dialog/#basic-example","title":"Basic Example","text":"<p>A dialog consists of the following components: <code>Dialog</code>, <code>DialogPanel</code> and the optional <code>Scrim</code>.</p> <p>The <code>Dialog</code> controls the visibility of the dialog via the <code>DialogState</code> object.</p> <p>The <code>DialogPanel</code> is a container component that renders the dialog's panel and its contents. </p> <p>The optional <code>Scrim</code> component is used to add layer behind the dialog and dim the rest of the UI.</p> <pre><code>val dialogState = rememberDialogState()\n\nBox {\n    Box(Modifier.clickable { dialogState.visible = true }) {\n        BasicText(\"Show Dialog\")\n    }\n    Dialog(state = dialogState) {\n        DialogPanel(\n            modifier = Modifier.systemBarsPadding()\n                .widthIn(min = 280.dp, max = 560.dp)\n                .padding(20.dp)\n                .clip(RoundedCornerShape(12.dp))\n                .border(1.dp, Color(0xFFE4E4E4), RoundedCornerShape(12.dp))\n                .background(Color.White),\n        ) {\n            Column {\n                Column(Modifier.padding(start = 24.dp, top = 24.dp, end = 24.dp)) {\n                    BasicText(\n                        text = \"Update Available\",\n                        style = TextStyle(fontWeight = FontWeight.Medium)\n                    )\n                    Spacer(Modifier.height(8.dp))\n                    BasicText(\n                        text = \"A new version of the app is available. Please update to the latest version.\",\n                        style = TextStyle(color = Color(0xFF474747))\n                    )\n                }\n                Spacer(Modifier.height(24.dp))\n                Box(Modifier.padding(12.dp)\n                    .align(Alignment.End)\n                    .clip(RoundedCornerShape(4.dp))\n                    .clickable(role = Role.Button) { /* TODO */ }\n                    .padding(horizontal = 12.dp, vertical = 8.dp)) {\n                    BasicText(\n                        text = \"Update\",\n                        style = TextStyle(color = Color(0xFF6699FF))\n                    )\n                }\n            }\n        }\n    }\n}\n</code></pre>"},{"location":"dialog/#styling","title":"Styling","text":"<p>Any sort of styling is done by the <code>Modifier</code> of the respective component.</p> <p>Changing the looks of the dialog's panel is done by passing the respective styling <code>Modifier</code>s to your <code>DialogPanel</code>:</p> <pre><code>Dialog(state = rememberDialogState(visible = true)) {\n    DialogPanel(\n        modifier = Modifier.systemBarsPadding()\n            .widthIn(min = 280.dp, max = 560.dp)\n            .padding(20.dp)\n            .clip(RoundedCornerShape(12.dp))\n            .border(1.dp, Color(0xFFE4E4E4), RoundedCornerShape(12.dp))\n            .background(Color.White)\n    ) {\n        Column {\n            BasicText(\"Something important happened\")\n            Box(Modifier.clickable { /* TODO */ }) {\n                BasicText(\"Got it\")\n            }\n        }\n    }\n}\n</code></pre>"},{"location":"dialog/#code-examples","title":"Code Examples","text":""},{"location":"dialog/#showinghide-the-dialog","title":"Showing/Hide the dialog","text":"<p>Pass your own <code>DialogState</code> to the <code>Dialog</code> and change the visible property according to your needs:</p> <pre><code>val state = rememberDialogState()\n\nBox(Modifier.clickable { state.visible = true }) {\n    BasicText(\"Show dialog\")\n}\nDialog(state = state) {\n    DialogPanel {\n        Column {\n            BasicText(\"Something important happened\")\n            Box(Modifier.clickable { state.visible = false }) {\n                BasicText(\"Got it\")\n            }\n        }\n    }\n}\n</code></pre> <p>The Dialog will also be automatically dismissed by default if the user taps outside the DialogPanel or presses the ' Escape' or 'Back' button on their device.</p> <p>In override to override this behavior pass the <code>DialogProperties</code> object to the Dialog with the desired properties:</p> <pre><code>Dialog(\n    state = rememberDialogState(),\n    properties = DialogProperties(dismissOnClickOutside = false, dismissOnBackPress = false)\n) {\n    // TODO the rest of your dialog\n}\n</code></pre>"},{"location":"dialog/#adding-a-scrim","title":"Adding a scrim","text":"<p>Use the <code>Scrim</code> component within your <code>Dialog</code>:</p> <pre><code>val state = rememberDialogState()\n\nBox(Modifier.clickable { state.visible = true }) {\n    BasicText(\"Show dialog\")\n}\nDialog(state = state) {\n    Scrim()\n    DialogPanel {\n        Column {\n            BasicText(\"Something important happened\")\n            Box(Modifier.clickable { state.visible = false }) {\n                BasicText(\"Got it\")\n            }\n        }\n    }\n}\n</code></pre> <p>The <code>Scrim</code> is customizable and you can pass any scrimColor, and enter/exit transitions that matches your design specs.</p>"},{"location":"dialog/#scrollable-dialogs","title":"Scrollable dialogs","text":"<p>Add any scrollable component such as <code>LazyColumn</code> to the contents of your dialog:</p> <pre><code>val state = rememberDialogState()\n\nBox(Modifier.clickable { state.visible = true }) {\n    BasicText(\"Show dialog\")\n}\nDialog(state = state) {\n    DialogPanel {\n        Column {\n            LazyColumn(Modifier.height(320.dp)) {\n                item { BasicText(\"Something important happened\") }\n                repeat(100) { i -&gt;\n                    item { BasicText(\"Update number ${i}\") }\n                }\n            }\n            Box(Modifier.clickable { state.visible = false }) {\n                BasicText(\"Got it\")\n            }\n        }\n    }\n}\n</code></pre>"},{"location":"dialog/#full-screen-dialogs","title":"Full-screen dialogs","text":"<p>Pass a <code>Modifier.fillMaxSize()</code> to the <code>DialogPanel</code>'s modifier parameter. Make sure to pass the <code>Modifier.systemBarsPadding()</code> or any related inset Modifier so that the dialog is not drawn behind any system bars (such as status and navigation bar on Android):</p> <pre><code>Dialog(state = rememberDialogState(visible = true)) {\n    DialogPanel(\n        modifier = Modifier\n            .systemBarsPadding()\n            .fillMaxSize()\n    ) {\n        Column {\n            BasicText(\"This is a full screen dialog\")\n            Box(Modifier.clickable { state.visible = false }) {\n                BasicText(\"Got it\")\n            }\n        }\n    }\n}\n</code></pre>"},{"location":"dialog/#adding-transitions","title":"Adding transitions","text":"<p>Add any enter/exit transitions into the <code>DialogPanel</code> and <code>Scrim</code> to control how they appear on the screen when they enter and exit the composition:</p> <pre><code>Dialog(state = rememberDialogState(visible = true)) {\n    Scrim(enter = fadeIn(), exit = fadeOut())\n    DialogPanel(\n        enter = scaleIn(initialScale = 0.8f) + fadeIn(tween(durationMillis = 250)),\n        exit = scaleOut(targetScale = 0.6f) + fadeOut(tween(durationMillis = 150)),\n    ) {\n        // TODO the dialog's contents\n    }\n}\n</code></pre>"},{"location":"dialog/#keyboard-interactions","title":"Keyboard Interactions","text":"Key Description Esc Closes any open dialogs, if the dismissOnBackPress of <code>DialogProperties()</code> is set to true. Back Closes any open dialogs, if the dismissOnBackPress of <code>DialogProperties()</code> is set to true. Tab Cycles through the dialog's contents. Shift + Tab Cycles through the dialog's contents in backwards order."},{"location":"dialog/#parameters","title":"Parameters","text":""},{"location":"dialog/#dialog_1","title":"Dialog","text":"<p>The main component.</p> Parameter Description <code>state</code> A <code>DialogState</code> object which controls the visibility of the dialog. <code>properties</code> Properties that control when the dialog needs to be dismissed (such as clicking outside of the panel or pressing Esc or Back. <code>content</code> A <code>@Composable</code> function that provides a <code>DialogScope</code>."},{"location":"dialog/#dialogpanel","title":"DialogPanel","text":"<p>The visual representation of your dialog. Can only be used from a <code>DialogScope</code>.</p> Parameter Description <code>state</code> A <code>DialogState</code> object which controls the visibility of the dialog. <code>properties</code> Properties that control when the dialog needs to be dismissed (such as clicking outside of the panel or pressing Esc or Back. <code>content</code> A <code>@Composable</code> function that provides a <code>DialogScope</code>."},{"location":"dialog/#scrim","title":"Scrim","text":"<p>The dimming layer that is often placed behind a <code>DialogPanel</code>, to let the user focus on the dialog. Can only be used from a <code>DialogScope</code>.</p> Parameter Description <code>modifier</code> <code>Modifier</code> for the Scrim <code>scrimColor</code> Controls the color of the Scrim. The default color is Black with an alpha of 60%. <code>enter</code> The <code>EnterTransition</code> when the Scrim enters the composition <code>exit</code> The <code>ExitTransition</code> when the Scrim enters the composition"},{"location":"dialog/#core-dialog-vs-compose-dialog","title":"Core Dialog vs Compose Dialog","text":"<p>Compose Multiplatform's original Dialog component does not support custom animations. Even though it is possible to animate it, it requires you to combine multiple components together and sync state to animations to composition which is not straightforward to do.</p> <p>In addition, the Jetpack Compose (Android) Dialog comes with the original Android's dialog width and inset constraints, which are historically a pain to deal with and customize.</p> <p>Our Dialog is designed to be customizable inside out and work the same way on every platform without surprises. It behaves like any other component. If for example you need a full screen dialog, all you have to do is pass <code>Modifier.fillMaxSize()</code> to the <code>DialogPanel</code>, without having to worry about platform flags.</p>"},{"location":"dialog/#styled-examples","title":"Styled Examples","text":"<p> <p>Looking for styled components for Compose Multiplatform?</p> <p>Explore a rich collection of production ready examples at ComposablesUi.com</p> <p> </p>"},{"location":"menu/","title":"Dropdown Menu","text":"<p>An unstyled component for Compose Multiplatform that can be used to implement Dropdown Menus with the styling of your choice. </p> <p>Fully accessible, supports keyboard navigation and open/close animations.</p>"},{"location":"menu/#installation","title":"Installation","text":"build.gradle.kts<pre><code>repositories {\n    mavenCentral()\n}\n\ndependencies {\n    implementation(\"com.composables:core:1.7.0\")\n}\n</code></pre>"},{"location":"menu/#basic-example","title":"Basic Example","text":"<p>There are four components that you will use to implement a dropdown: <code>Menu</code>, <code>MenuButton</code>, <code>MenuContent</code> and <code>MenuItem</code>.</p> <p>The <code>Menu</code> wraps the <code>MenuButton</code> and the <code>MenuContent</code> components. When the <code>MenuButton</code> is clicked, the <code>MenuContent</code> will be displayed on the screen at the position relative to the <code>Menu</code>.</p> <p>The <code>MenuContent</code> component wraps multiple <code>MenuItem</code>s. When a <code>MenuItem</code> is clicked, the menu is dismissed. Each <code>MenuItem</code> has a <code>onClick</code> parameter you can use for interaction purposes.</p> <p>The menu's dropdown visibility is handled for you thanks to the <code>Menu</code>'s internal state.</p> <pre><code>val options = listOf(\"United States\", \"Greece\", \"Indonesia\", \"United Kingdom\")\nvar selected by remember { mutableStateOf(0) }\n\nColumn(Modifier.fillMaxSize()) {\n    Menu(Modifier.align(Alignment.End)) {\n        MenuButton(\n            Modifier.clip(RoundedCornerShape(6.dp))\n                .border(1.dp, Color(0xFFBDBDBD), RoundedCornerShape(6.dp))\n        ) {\n            Row(\n                modifier = Modifier.padding(horizontal = 14.dp, vertical = 10.dp),\n                verticalAlignment = Alignment.CenterVertically,\n            ) {\n                BasicText(\"Options\", style = defaultTextStyle.copy(fontWeight = FontWeight(500)))\n                Spacer(Modifier.width(4.dp))\n                Image(ChevronDown, null)\n            }\n        }\n\n        MenuContent(\n            modifier = Modifier.width(320.dp)\n                .border(1.dp, Color(0xFFE0E0E0), RoundedCornerShape(4.dp))\n                .background(Color.White)\n                .padding(4.dp),\n            hideTransition = fadeOut()\n        ) {\n            options.forEachIndexed { index, option -&gt;\n                MenuItem(\n                    modifier = Modifier.clip(RoundedCornerShape(4.dp)),\n                    onClick = { selected = index }\n                ) {\n                    BasicText(option, modifier = Modifier.fillMaxWidth().padding(vertical = 8.dp, horizontal = 4.dp))\n                }\n            }\n        }\n    }\n    BasicText(\"Selected = ${options[selected]}\")\n}\n</code></pre>"},{"location":"menu/#code-examples","title":"Code Examples","text":""},{"location":"menu/#expandclose-the-menu-programmatically","title":"Expand/Close the Menu programmatically","text":"<p>Pass your own <code>MenuState</code> to the <code>Menu</code> and change the expanded property according to your needs:</p> <pre><code>val state = rememberMenuState(expanded = true)\n\nMenu(state = state) {\n    MenuButton {\n        BasicText(\"Toggle the menu\")\n    }\n\n    MenuContent {\n        MenuItem(onClick = { state.expanded = false }) {\n            BasicText(\"Close this menu\")\n        }\n    }\n}\n</code></pre>"},{"location":"menu/#change-the-alignment-of-the-menucontent","title":"Change the alignment of the <code>MenuContent</code>","text":"<p>This option is useful if you want to left align, center align or right align the <code>MenuButton</code> and the <code>MenuContent</code> when expanded.</p> <pre><code>Menu {\n    MenuButton {\n        BasicText(\"Toggle the menu\")\n    }\n\n    MenuContent(alignment = Alignment.End) {\n        MenuItem(onClick = { /* TODO */ }) {\n            BasicText(\"Option\")\n        }\n    }\n}\n</code></pre>"},{"location":"menu/#styling","title":"Styling","text":"<p>By default, the Menu component comes with no styling. This is by design as it is intended to be used as a building block for your own design system's menus.</p> <p>The <code>Menu</code> composable is used as an anchor point. Do not pass any styling to its <code>modifier</code>. Instead, use its <code>modifier</code> parameter for anchoring and positioning needs (such as <code>Modifier.align()</code>).</p> <p>The <code>MenuButton</code> is the composable responsible to handle clicking into showing and hiding the dropdown menu.</p> <p>The following sample shows the minimum setup you need to display something on the screen:</p> <pre><code>Menu {\n    MenuButton {\n        BasicText(\"Show Options\")\n    }\n\n    MenuContent {\n        MenuItem(onClick = { /* TODO handle click */ }) {\n            BasicText(\"Option 1\")\n        }\n        MenuItem(onClick = { /* TODO handle click */ }) {\n            BasicText(\"Option 2\")\n        }\n        MenuItem(onClick = { /* TODO handle click */ }) {\n            BasicText(\"Option 3\")\n        }\n    }\n}\n</code></pre> <p>However, the result will not look pretty. The following section goes over how to style each component to achieve the visual results you want.</p>"},{"location":"menu/#styling-the-menu-button","title":"Styling the Menu Button","text":"<p>Pass the desired styling to the <code>MenuButton</code>'s <code>modifier</code>. Do not pass any padding to it, as the <code>MenuButton</code> handles click events internally and this will affect the interaction bounds.</p> <p>Instead, provide any content padding to the contents of the button instead:</p> <pre><code>Menu {\n    MenuButton(Modifier.clip(RoundedCornerShape(6.dp)).border(1.dp, Color(0xFFBDBDBD), RoundedCornerShape(6.dp))) {\n        BasicText(\"Options\", modifier = Modifier.padding(vertical = 8.dp, horizontal = 4.dp))\n    }\n\n    MenuContent {\n        MenuItem(onClick = { /* TODO handle click */ }) {\n            BasicText(\"Option 1\")\n        }\n        MenuItem(onClick = { /* TODO handle click */ }) {\n            BasicText(\"Option 2\")\n        }\n        MenuItem(onClick = { /* TODO handle click */ }) {\n            BasicText(\"Option 3\")\n        }\n    }\n}\n</code></pre>"},{"location":"menu/#styling-the-menucontent","title":"Styling the MenuContent","text":"<p>The <code>MenuContent</code> component is a layout on which the menu's items will be displayed when the menu is expanded. In Material Design this is often a card.</p> <pre><code>Menu {\n    MenuButton(Modifier.clip(RoundedCornerShape(6.dp)).border(1.dp, Color(0xFFBDBDBD), RoundedCornerShape(6.dp))) {\n        BasicText(\"Options\", modifier = Modifier.padding(vertical = 8.dp, horizontal = 4.dp))\n    }\n\n    MenuContent(Modifier.width(320.dp).border(1.dp, Color(0xFFE0E0E0), RoundedCornerShape(4.dp)).background(Color.White).padding(4.dp)) {\n        MenuItem(onClick = { selected = index }) {\n            Text(option, modifier = Modifier.fillMaxWidth().padding(vertical = 8.dp, horizontal = 4.dp))\n        }\n    }\n}\n</code></pre>"},{"location":"menu/#animating-the-menu","title":"Animating the Menu","text":"<p>Modify the <code>showTransition</code> and <code>hideTransition</code> parameters of the <code>MenuContent</code> component to modify the animation specs of the dropdown menu when it is visible/hidden.</p> <p>The <code>MenuContent</code> use the <code>AnimatedVisiblity</code> composable internally, which gives you a lot of flexibility towards what you can achieve.</p>"},{"location":"menu/#animation-recipes","title":"Animation Recipes","text":""},{"location":"menu/#material-design-dropdown-animation","title":"Material Design Dropdown Animation","text":"<p>Material Design scales and fades the dropdown in and out.</p> <pre><code>MenuContent(\n    modifier = Modifier.width(320.dp).border(1.dp, Color(0xFFE0E0E0), RoundedCornerShape(4.dp)).background(Color.White).padding(4.dp),\n    showTransition = scaleIn(tween(durationMillis = 120, easing = LinearOutSlowInEasing), initialScale = 0.8f, transformOrigin = TransformOrigin(0f, 0f)) + fadeIn(tween(durationMillis = 30)),\n    hideTransition = scaleOut(tween(durationMillis = 1, delayMillis = 75), targetScale = 1f) + fadeOut(tween(durationMillis = 75))\n) {\n    MenuItem(onClick = { /* TODO */ }) {\n        Basictext(\"Option 1\")\n    }\n    MenuItem(onClick = { /* TODO */ }) {\n        Basictext(\"Option 2\")\n    }\n}\n</code></pre>"},{"location":"menu/#mac-os-menu-animations","title":"Mac OS Menu Animations","text":"<p>macOS shows the menu instantly on click, and quickly fades the menu out when dismissed:</p> <pre><code>MenuContent(hideTransition = fadeOut(tween(durationMillis = 100, easing = LinearEasing))) {\n    MenuItem(onClick = { /* TODO */ }) {\n        Basictext(\"Option 1\")\n    }\n}\n</code></pre>"},{"location":"menu/#styling-touch-presses-and-focus","title":"Styling touch presses and focus","text":"<p><code>MenuItem</code>'s uses the default Compose mechanism for providing touch and focus feedback. Use the <code>LocalIndication</code> CompositionLocal to override the default indication.</p> <p>Here is an example of using Material Design's signature ripple feedback with your menu:</p> <pre><code>import androidx.compose.foundation.LocalIndication\nimport androidx.compose.material.ripple.rememberRipple\n\nCompositionLocalProvider(LocalIndication provides rememberRipple()) {\n    // MenuButton and MenuContent will use the ripple effect when focused and pressed\n\n    Menu {\n        // TODO implement the rest of the menu\n    }\n}\n</code></pre>"},{"location":"menu/#keyboard-interactions","title":"Keyboard Interactions","text":"Key Description Enter Opens the Menu, if the <code>MenuButton</code> is focused. Performs a click, when a <code>MenuItem</code> is focused. \u2b07 Opens the Menu, if the <code>MenuButton</code> is focused. Moves focus to the next <code>MenuItem</code> if the <code>Menu</code> is expanded. \u2b06 Moves focus to the previous <code>MenuItem</code> if the <code>Menu</code> is expanded. Esc Closes the Menu, if the Menu is expanded and moves focus to the <code>MenuButton</code>. Removes focus if the <code>MenuButton</code> is focused."},{"location":"menu/#styled-examples","title":"Styled Examples","text":"<p> <p>Looking for styled components for Compose Multiplatform?</p> <p>Explore a rich collection of production ready examples at ComposablesUi.com</p> <p> </p>"}]}